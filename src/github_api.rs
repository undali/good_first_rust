use chrono::{DateTime, Utc};
use reqwest::Client;
use std::time::Duration;

use crate::db;
use crate::models::{GitHubSearchResponse, Issue, RepositoryInfo};

const GITHUB_API_BASE: &str = "https://api.github.com";

trait RateLimit {
    fn get_rate_limit_info(&self) -> String;
}

impl RateLimit for reqwest::Response {
    fn get_rate_limit_info(&self) -> String {
        // x-ratelimit-remaining
        // x-ratelimit-used
        // x-ratelimit-resource

        let mut max_limit = 0;
        let mut limit_used = 0;
        let mut reset_at = 0u64;
        let mut resource = "unknown";
        if let Some(rate_limit_limit) = self.headers().get("x-ratelimit-limit") {
            max_limit = rate_limit_limit
                .to_str()
                .unwrap_or_default()
                .parse::<i32>()
                .unwrap_or(-1);
        }
        if let Some(rate_limit_remaining) = self.headers().get("x-ratelimit-used") {
            limit_used = rate_limit_remaining
                .to_str()
                .unwrap_or_default()
                .parse::<i32>()
                .unwrap_or(-1);
        }
        if let Some(rate_limit_reset) = self.headers().get("x-ratelimit-reset") {
            reset_at = rate_limit_reset
                .to_str()
                .unwrap_or_default()
                .parse::<u64>()
                .unwrap_or(0);
        }
        if let Some(rate_limit_resource) = self.headers().get("x-ratelimit-resource") {
            resource = rate_limit_resource.to_str().unwrap_or_default();
        }

        format!(
            "Rate limit: {limit_used}/{max_limit} Reset at: {} Resource: {resource}",
            DateTime::from_timestamp_secs(reset_at as i64).unwrap_or_default()
        )
    }
}

/// Parse ISO 8601 datetime string to Unix timestamp (seconds)
fn parse_datetime_to_timestamp(datetime_str: &str) -> i64 {
    DateTime::parse_from_rfc3339(datetime_str)
        .map(|dt| dt.timestamp())
        .unwrap_or_else(|_| Utc::now().timestamp())
}

pub async fn fetch_and_store_issues() -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new();

    // Fetch issues with filters: label:good first issue, language:rust, state:open
    let query = "q=label:%22good%20first%20issue%22%20language:rust%20state:open&per_page=100";
    let url = format!("{}/search/issues?{}", GITHUB_API_BASE, query);

    tracing::info!("Fetching issues from: {}", url);

    let response = client
        .get(&url)
        .header("User-Agent", "gh-issue-browser")
        .timeout(Duration::from_secs(30))
        .send()
        .await?;

    tracing::info!("Rate limit info: {}", response.get_rate_limit_info());

    if !response.status().is_success() {
        let status = response.status();
        let body = response.text().await?;
        tracing::error!("GitHub API error: {} - {}", status, body);
        return Err(format!("GitHub API error: {} - {}", status, body).into());
    }

    let search_result: GitHubSearchResponse = response.json().await?;
    tracing::info!("Fetched {} issues", search_result.items.len());

    for github_issue in search_result.items {
        // Extract repo name from repository_url
        let repo_name = github_issue
            .repository_url
            .split('/')
            .rev()
            .take(2)
            .collect::<Vec<_>>()
            .into_iter()
            .rev()
            .collect::<Vec<_>>()
            .join("/");

        // Get or fetch stargazer count
        let star_count = get_or_fetch_stargazer_count(&client, &repo_name).await?;

        // Convert ISO datetime to Unix timestamp
        let created_at = parse_datetime_to_timestamp(&github_issue.created_at);

        // Create issue record
        let issue = Issue {
            id: 0, // Will be auto-generated by DB
            repo_name,
            url: github_issue.url,
            creator: github_issue.user.login,
            created_at,
            title: github_issue.title,
            labels: github_issue
                .labels
                .iter()
                .map(|l| l.name.clone())
                .collect::<Vec<_>>()
                .join(", "),
            star_count,
        };

        // Insert issue to database
        if let Err(e) = db::insert_issue(&issue) {
            tracing::warn!("Failed to insert issue {}: {:?}", issue.url, e);
        }
    }

    Ok(())
}

async fn get_or_fetch_stargazer_count(
    client: &Client,
    repo_name: &str,
) -> Result<i64, Box<dyn std::error::Error>> {
    // Check if we have cached stargazer count
    if let Ok(Some(cached)) = db::get_stargazer_count(repo_name) {
        // Calculate age using Unix timestamps
        let now = Utc::now().timestamp();
        let age_hours = (now - cached.updated_at) / 3600;

        if age_hours < 24 {
            tracing::debug!(
                "Using cached stargazer count for {}: {}",
                repo_name,
                cached.star_count
            );
            return Ok(cached.star_count);
        }
    }

    // Fetch from GitHub API
    let url = format!("{}/repos/{}", GITHUB_API_BASE, repo_name);
    tracing::debug!("Fetching stargazer count from: {}", url);

    let response = client
        .get(&url)
        .header("User-Agent", "gh-issue-browser")
        .timeout(Duration::from_secs(10))
        .send()
        .await?;
// thefinaltool.com
    tracing::info!("Rate limit info: {}", response.get_rate_limit_info());

    if !response.status().is_success() {
        let status = response.status();
        let body = response.text().await?;
        tracing::error!(
            "Failed to fetch stargazer count for {}: {} - {}",
            repo_name,
            status,
            body
        );
        return Err(format!("GitHub API error: {}", status).into());
    }

    let repo_info: RepositoryInfo = response.json().await?;

    // Store in database
    db::insert_or_update_stargazer_count(repo_name, repo_info.stargazers_count)?;

    Ok(repo_info.stargazers_count)
}
